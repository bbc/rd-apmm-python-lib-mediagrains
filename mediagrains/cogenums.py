#
# Copyright 2018 British Broadcasting Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This file was automatically generated by extract_enums from Cog2
# Date: 2018-02-21T15:34:00.140398
# Git revision: a3102d4d8d75d07b41ddb4c14660ffc6beaab582
#
# Cog2 is a BBC internal C media processing library, this file ensures
# that python code using it is compatible with this library when specifying
# video and audio formats.

from enum import IntEnum

__all__ = [
    'CogFrameFormat',
    'CogFrameLayout',
    'CogAudioFormat',
    'COG_FRAME_IS_PACKED',
    'COG_FRAME_IS_COMPRESSED',
    'COG_FRAME_IS_PLANAR',
    'COG_FRAME_IS_PLANAR_RGB',
    'COG_FRAME_FORMAT_BYTES_PER_VALUE',
    'COG_FRAME_FORMAT_H_SHIFT',
    'COG_FRAME_FORMAT_V_SHIFT',
    'COG_FRAME_FORMAT_ACTIVE_BITS']


class CogFrameFormat(IntEnum):
    MJPEG = 0x200
    DNxHD = 0x201
    MPEG2 = 0x202
    AVCI = 0x203
    H264 = 0x204
    DV = 0x205
    D10 = 0x206
    VC2 = 0x207
    VP8 = 0x208
    ALPHA_U8_1BIT = 0x1080
    U8_444 = 0x2000
    U8_422 = 0x2001
    U8_420 = 0x2003
    U8_444_RGB = 0x2010
    ALPHA_U8 = 0x2080
    YUYV = 0x2100
    UYVY = 0x2101
    AYUV = 0x2102
    RGB = 0x2104
    RGBx = 0x2110
    xRGB = 0x2111
    BGRx = 0x2112
    xBGR = 0x2113
    RGBA = 0x2114
    ARGB = 0x2115
    BGRA = 0x2116
    ABGR = 0x2117
    S16_444_10BIT = 0x2804
    S16_444_10BIT_RGB = 0x2814
    S16_422_10BIT = 0x2805
    S16_420_10BIT = 0x2807
    ALPHA_S16_10BIT = 0x2884
    v210 = 0x2906
    S16_444_12BIT = 0x3004
    S16_444_12BIT_RGB = 0x3014
    S16_422_12BIT = 0x3005
    S16_420_12BIT = 0x3007
    ALPHA_S16_12BIT = 0x3084
    S16_444 = 0x4004
    S16_444_RGB = 0x4014
    S16_422 = 0x4005
    S16_420 = 0x4007
    ALPHA_S16 = 0x4084
    v216 = 0x4105
    S32_444 = 0x8008
    S32_444_RGB = 0x8018
    S32_422 = 0x8009
    S32_420 = 0x800b
    ALPHA_S32 = 0x8088
    UNKNOWN = 0xfffffffe
    INVALID = 0xffffffff


class CogFrameLayout(IntEnum):
    FULL_FRAME = 0x0
    SEPARATE_FIELDS = 0x1
    SINGLE_FIELD = 0x2
    MIXED_FIELDS = 0x3
    SEGMENTED_FRAME = 0x4
    UNKNOWN = 0xfffffffe


class CogAudioFormat(IntEnum):
    S16_PLANES = 0x0
    S16_PAIRS = 0x1
    S16_INTERLEAVED = 0x2
    S24_PLANES = 0x4
    S24_PAIRS = 0x5
    S24_INTERLEAVED = 0x6
    S32_PLANES = 0x8
    S32_PAIRS = 0x9
    S32_INTERLEAVED = 0xa
    S64_INVALID = 0xc
    FLOAT_PLANES = 0x18
    FLOAT_PAIRS = 0x19
    FLOAT_INTERLEAVED = 0x1a
    DOUBLE_PLANES = 0x2c
    DOUBLE_PAIRS = 0x2d
    DOUBLE_INTERLEAVED = 0x2e
    MP1 = 0x200
    AAC = 0x201
    OPUS = 0x202
    UNKNOWN = 0xfffffffe
    INVALID = 0xffffffff


class PlanarChromaFormat(IntEnum):
    YUV_444 = 0x00
    YUV_422 = 0x01
    YUV_420 = 0x03
    RGB = 0x10


def COG_PLANAR_FORMAT(chroma: PlanarChromaFormat, depth: int) -> CogFrameFormat:
    if depth <= 8:
        return CogFrameFormat(0 + chroma + (depth << 10))
    elif depth > 16:
        return CogFrameFormat(8 + chroma + (depth << 10))
    else:
        return CogFrameFormat(4 + chroma + (depth << 10))


def COG_FRAME_IS_PACKED(fmt: CogFrameFormat) -> bool:
    return ((fmt >> 8) & 0x1) != 0


def COG_FRAME_IS_COMPRESSED(fmt: CogFrameFormat) -> bool:
    return ((fmt >> 9) & 0x1) != 0


def COG_FRAME_IS_PLANAR(fmt: CogFrameFormat) -> bool:
    return ((fmt >> 8) & 0x3) == 0


def COG_FRAME_IS_ALPHA(fmt: CogFrameFormat) -> bool:
    return ((fmt >> 7) & 0x1) != 0


def COG_FRAME_IS_PLANAR_RGB(fmt: CogFrameFormat) -> bool:
    return ((fmt >> 4) & 0x31) == 1


def COG_FRAME_FORMAT_BYTES_PER_VALUE(fmt: CogFrameFormat) -> int:
    if ((fmt) & 0xc) == 0:
        return 1
    elif ((fmt) & 0xc) == 4:
        return 2
    else:
        return 4


def COG_FRAME_FORMAT_H_SHIFT(fmt: CogFrameFormat) -> int:
    return (fmt & 0x1)


def COG_FRAME_FORMAT_V_SHIFT(fmt: CogFrameFormat) -> int:
    return ((fmt >> 1) & 0x1)


def COG_FRAME_FORMAT_ACTIVE_BITS(fmt: CogFrameFormat) -> int:
    return (((int(fmt)) >> 10) & 0x3F)


def COG_AUDIO_IS_PLANES(fmt: CogAudioFormat) -> bool:
    return (fmt & 0x3) == 0


def COG_AUDIO_IS_PAIRS(fmt: CogAudioFormat) -> bool:
    return (fmt & 0x3) == 1


def COG_AUDIO_IS_INTERLEAVED(fmt: CogAudioFormat) -> bool:
    return (fmt & 0x3) == 2


def COG_AUDIO_IS_COMPRESSED(fmt: CogAudioFormat) -> bool:
    return (fmt & 0x200) == 0x200


def COG_AUDIO_IS_INT(fmt: CogAudioFormat) -> bool:
    return (fmt & 0x030) == 0x000


def COG_AUDIO_IS_FLOAT(fmt: CogAudioFormat) -> bool:
    return (fmt & 0x030) == 0x010


def COG_AUDIO_IS_DOUBLE(fmt: CogAudioFormat) -> bool:
    return (fmt & 0x030) == 0x020


COG_AUDIO_FORMAT_DEPTH_S16 = 0x00
COG_AUDIO_FORMAT_DEPTH_S24 = 0x04
COG_AUDIO_FORMAT_DEPTH_S32 = 0x08
COG_AUDIO_FORMAT_DEPTH_S64 = 0x0c


def COG_AUDIO_FORMAT_DEPTH(fmt: CogAudioFormat) -> int:
    return fmt & 0xc


def COG_AUDIO_FORMAT_SAMPLEBYTES(fmt: CogAudioFormat) -> int:
    if COG_AUDIO_FORMAT_DEPTH(fmt) == COG_AUDIO_FORMAT_DEPTH_S64:
        return 8
    elif COG_AUDIO_IS_PLANES(fmt) and COG_AUDIO_FORMAT_DEPTH(fmt) == COG_AUDIO_FORMAT_DEPTH_S24:
        return (((fmt & 0xf) >> 2) & 0x07) + 3
    else:
        return (((fmt & 0xf) >> 2) & 0x07) + 2
