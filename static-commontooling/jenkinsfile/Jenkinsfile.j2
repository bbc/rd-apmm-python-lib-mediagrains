{%- set
    uploads = []
-%}
{%- if default_branch is not defined -%}
{%- set default_branch = "main" -%}
{%- endif -%}
{%- for stage in stages | parse_jcdsl_list | default([]) -%}
{%-   if stage.cmd == "@upload" -%}
{%-     do uploads.append(stage.subcmd.cmd) -%}
{%-   endif -%}
{%- endfor -%}
@Library("{{ library | default("rd-apmm-groovy-ci-library@v1.x") }}") _

/*

    This file was autogenerated using tooling in commontooling

    DO NOT MANUALLY EDIT THIS FILE

    Instead make necessary changes to Jenkinsfile.json and then
    regenerate this file with `make Jenkinsfile` before checking
    the resulting file into git.

 */

pipeline {
    agent {
        label "{{ agent | default("ubuntu&&apmm-agent") }}"
    }
    options {
        ansiColor('xterm') // Add support for coloured output
        buildDiscarder(logRotator(numToKeepStr: '10')) // Discard old builds
{%- for option in options | default([]) %}
        {{ option }}
{%- endfor %}
    }
    triggers {
{%- for trigger in triggers | default(["cron(env.BRANCH_NAME == '" + default_branch + "' ? 'H H(0-8) * * *' : '') // Build " + default_branch + " some time every morning"]) %}
        {{ trigger }}
{%- endfor %}
    }
    parameters {
{%- if "docs" in uploads or "docs-recursive" in uploads %}
        booleanParam(name: "FORCE_DOCSUPLOAD", defaultValue: false, description: "Force API docs upload")
{%- endif %}
{%- if "artifactory" in uploads %}
        booleanParam(name: "FORCE_ARTIFACTORYUPLOAD", defaultValue: false, description: "Force upload of python wheels to artifactory")
{%- endif %}
{%- if "pypi" in uploads %}
        booleanParam(name: "FORCE_PYPIUPLOAD", defaultValue: false, description: "Force upload of python wheels to pypi")
{%- endif %}
{%- if "docker" in uploads %}
        booleanParam(name: "FORCE_DOCKERUPLOAD", defaultValue: false, description: "Force upload of docker images to artifactory")
{%- endif %}
{%- if "snapshotmanifest" in uploads %}
        booleanParam(name: "FORCE_SNAPSHOTUPLOAD", defaultValue: false, description: "Force upload of service deployment artefacts to S3")
{%- endif %}
        string(name: "PYTHON_VERSION", defaultValue: "{{ python_version | default("3.10") }}", description: "Python version to make available in tox")
        string(name: "COMMONTOOLING_BRANCH", defaultValue: "{{ commontooling_branch | default("main") }}")
{%- for parameter in parameters | default([]) %}
        {{ parameter }}
{%- endfor %}
    }
    environment {
        FORGE_CERT = "{{ forge_cert | default("/etc/pki/tls/private/client_crt_key.pem") }}"
        http_proxy = "http://www-cache.rd.bbc.co.uk:8080"
        https_proxy = "http://www-cache.rd.bbc.co.uk:8080"
        PATH = "$HOME/.pyenv/bin:$PATH"
        TOX_WORK_DIR="/tmp/${sh(script: "basename ${WORKSPACE}", , returnStdout: true).trim()}"
{%- if docker is defined and docker %}
        WITH_DOCKER = "true"
{%- endif %}
        TOX_ENV = "py${(params.PYTHON_VERSION =~ /(\d+)\.(\d+).*/)[0][1..2].join('')}"
        DOCKER_CONFIG = "$WORKSPACE/docker-config/"
{%- for env in environment | default([]) %}
        {{ env }}
{%- endfor %}
    }
    stages {
{%- for stage in stages | parse_jcdsl_list | default([]) %}
{%-   if not stage.cmd.startswith('@') %}
        {{ stage.cmd }}
{%-   else %}
{%-     if stage.cmd == "@setup" %}
        stage("Setup Environment") {
            steps {
                bbcStageSetupEnvironment({{ stage.params | default("", true) }})
            }
            post {
                always {
                    bbcGithubNotify(context: "prepcode", status: env.result)
                }
            }
        }
{%-     elif stage.cmd == "@agentsh" %}
        stage ('sh \"{{ stage.params }}\"') {
            steps {
                sh "{{ stage.params }}"
            }
        }
{%-     elif stage.cmd == "@sh" %}
        stage ('bbcSh \"{{ stage.params }}\"') {
            steps {
                bbcSh "{{ stage.params }}"
            }
        }
{%-     elif stage.cmd == "@make" %}
        stage ("make {{ stage.tgt }}") {
            steps {
{%-       if stage.ctx %}
                {{ stage.ctx }} {
                    bbcMake '{{ stage.tgt }}'
                }
{%-       else %}
                bbcMake '{{ stage.tgt }}'
{%-       endif %}
            }
            post {
                always {
                    bbcGithubNotify(context: "{{ stage.tgt }}", status: env.result)
                }
            }
        }
{%-     elif stage.cmd == "@ramltest" %}
        stage ("RAML Test") {
            steps {
                bbcMake("up ramltest", statusContext: "test/raml")
            }
            post {
                always {
                    bbcGithubNotify(context: "test/raml", status: env.result)
                }
                cleanup {
                    bbcMake("down", statusContext: "")
                }
            }
        }
{%-     elif stage.cmd == "@wheel" %}
        stage ("Build {{ stage.tgt | default('package', true) }} wheels") {
            steps {
                withBBCStatusRecording(context: 'wheel/{{ stage.tgt | default('package', true) }}') {
                    withBBCRDPythonArtifactory {
                        bbcMakeWheel(toxenv: "${env.TOX_ENV}", path: "{{ stage.tgt | default('.', true) }}")
                    }
                }
            }
            post {
                always {
                    bbcGithubNotify(context: "wheel/{{ stage.tgt | default('package', true) }}", status: env.result)
                }
            }
        }
{%-     elif stage.cmd == "@upload" %}
{%-       if stage.subcmd.cmd in ("docs", "docs-recursive") %}
        stage ("Upload Docs") {
            when {
                anyOf {
                    expression { return params.FORCE_DOCSUPLOAD }
                    expression { env.TAG_NAME != null }
                    expression {
                        bbcShouldUploadArtifacts(branches: ["{{ default_branch }}"])
                    }
                }
            }
            steps {
                withBBCStatusRecording(context: 'upload/docs') {
                    bbcAPMMDocsUpload(sourceFiles: "{{ stage.subcmd.params | default("./docs/*.html", true) }}", recursive: {{ "true" if stage.subcmd.cmd == "docs-recursive" else "false" }})
                }
            }
            post {
                always {
                    bbcGithubNotify(context: "upload/docs", status: env.result)
                }
            }
        }
{%-       elif stage.subcmd.cmd == "artifactory" %}
        stage ("Upload {{ stage.subcmd.dir | default('package', true) }} to Artifactory") {
            when {
                anyOf {
                    expression { return params.FORCE_ARTIFACTORYUPLOAD }
                    expression { env.TAG_NAME != null }
                    expression {
                        bbcShouldUploadArtifacts(branches: ["{{ default_branch }}"])
                    }
                }
            }
            steps {
                bbcMake "upload-wheels"
            }
            post {
                always {
                    bbcGithubNotify(context: "upload-wheels", status: env.result)
                }
            }
        }
{%-       elif stage.subcmd.cmd == "pypi" %}
        stage ("Upload to PyPi") {
            when {
                anyOf {
                    expression { return params.FORCE_PYPIUPLOAD }
                    expression { env.TAG_NAME != null }
                    expression {
                        bbcShouldUploadArtifacts(branches: ["{{ default_branch }}"])
                    }
                }
            }
            steps {
                withCredentials([usernamePassword(credentialsId: "5f2c0fcd-cf71-494a-a642-aa072100171b",
                        passwordVariable: 'TWINE_REPO_PASSWORD',
                        usernameVariable: 'TWINE_REPO_USERNAME')]) {
                    withEnv(["TWINE_REPO=https://upload.pypi.org/legacy/"]) {
                        bbcMake "upload-wheels"
                    }
                }
            }
            post {
                always {
                    bbcGithubNotify(context: "upload-wheels", status: env.result)
                }
            }
        }
{%-       elif stage.subcmd.cmd == "snapshotmanifest" %}
        stage ("Upload Deployment Snapshot Manifest") {
            when {
                anyOf {
                    expression { return params.FORCE_SNAPSHOTUPLOAD }
                    expression { env.TAG_NAME != null }
                    expression {
                        bbcIsOnBranch(branches: ["{{ default_branch }}"])
                    }
                }
            }
            steps {
                // We can't use bbcMake here because the AWS credentials have to be passed through
                withBBCStatusRecording(context: 'upload/snapshotmanifest') {
                    withBBCAWSCredentialsFile(awsAccountID: "613414153832", role: "jenkins-artefact-upload") {
                        // Set profile as well as credentials file to override any other changes to profile in environment
                        sh("make snapshotmanifest")
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'dist/*_snapshot_manifest*', fingerprint: true, onlyIfSuccessful: true
                    bbcGithubNotify(context: "upload/snapshotmanifest", status: env.result)
                }
            }
        }
{%-       elif stage.subcmd.cmd == "docker" %}
        stage ("Upload docker images to Artifactory") {
            when {
                anyOf {
                    expression { return params.FORCE_DOCKERUPLOAD }
                    expression { env.TAG_NAME != null }
                    expression {
                        bbcShouldUploadArtifacts(branches: ["{{ default_branch }}"])
                    }
                }
            }
            steps {
                withBBCDockerRegistry {
                    bbcMake "upload-docker"
                }
            }
            post {
                always {
                    bbcGithubNotify(context: "upload-docker", status: env.result)
                    bbcSh "docker logout ap-docker.virt.ch.bbc.co.uk:443"
                }
            }
        }
{%-       endif %}
{%-     endif %}
{%-   endif %}
{%- endfor %}
    }
    post {
        always {
            bbcSlackNotify(channel: "{{ slack_notify_channel | default("#apmm-cloudfit") }}")
        }
    }
}
